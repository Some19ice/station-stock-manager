// Mock the Clerk auth module BEFORE importing anything else
const mockAuth = jest.fn()
jest.mock("@clerk/nextjs/server", () => ({
  auth: mockAuth
}))

// Mock the database module
const mockDb = {
  query: {
    users: {
      findFirst: jest.fn()
    }
  },
  transaction: jest.fn(),
  insert: jest.fn()
}

jest.mock("@/db", () => ({
  db: mockDb
}))

// Mock Drizzle ORM operators
jest.mock("drizzle-orm", () => ({
  eq: jest.fn(() => "eq-condition")
}))

// Mock Zod to return input data without validation (for most tests)
const mockZodParse = jest.fn()
const mockZodObject = jest.fn(() => ({
  parse: mockZodParse
}))

jest.mock("zod", () => ({
  z: {
    object: mockZodObject,
    string: jest.fn(() => ({
      min: jest.fn(() => ({}))
    })),
    enum: jest.fn(() => ({}))
  }
}))

// Now import the action after all mocks are set up
const {
  setupUserProfile
} = require("@/app/(unauthenticated)/setup-profile/_actions/setup-profile")

describe("Setup Profile Action", () => {
  const createTestUUID = (suffix: string = "0000") => {
    return `550e8400-e29b-41d4-a716-44665544${suffix.padStart(4, "0")}`
  }

  const validInput = {
    clerkUserId: "test-user-id",
    stationName: "Test Station",
    stationAddress: "123 Test Street",
    username: "testuser",
    role: "manager"
  }

  beforeEach(() => {
    // Clear all mocks
    jest.clearAllMocks()

    // Set up default Zod behavior to pass input through
    mockZodParse.mockImplementation(input => input)

    // Set up default successful authentication
    mockAuth.mockResolvedValue({ userId: "test-user-id" })

    // Set up default database behavior - no existing users
    mockDb.query.users.findFirst.mockResolvedValue(null)

    // Set up successful transaction mock
    mockDb.transaction.mockImplementation(async callback => {
      const mockTx = {
        insert: jest.fn().mockReturnValue({
          values: jest.fn().mockReturnValue({
            returning: jest.fn().mockResolvedValue([
              {
                id: createTestUUID("1001"),
                userId: "test-user-id",
                membership: "free",
                stripeCustomerId: null
              }
            ])
          })
        })
      }

      // Mock the transaction to return the expected structure
      return {
        user: {
          id: createTestUUID("3001"),
          stationId: createTestUUID("2001"),
          clerkUserId: "test-user-id",
          username: validInput.username,
          role: validInput.role
        },
        station: {
          id: createTestUUID("2001"),
          customerId: createTestUUID("1001"),
          name: validInput.stationName,
          address: validInput.stationAddress || null
        }
      }
    })
  })

  afterEach(() => {
    jest.clearAllMocks()
  })

  describe("setupUserProfile", () => {
    it("should create complete profile for new manager", async () => {
      const result = await setupUserProfile({
        ...validInput,
        username: "newmanager",
        stationName: "New Filling Station",
        stationAddress: "789 New Street"
      })

      expect(result.isSuccess).toBe(true)
      expect(result.data?.user.username).toBe("newmanager")
      expect(result.data?.user.role).toBe("manager")
      expect(result.data?.station.name).toBe("New Filling Station")
      expect(mockDb.transaction).toHaveBeenCalledTimes(1)
    })

    it("should create complete profile for new staff", async () => {
      // Update transaction mock for staff role
      mockDb.transaction.mockImplementationOnce(async callback => ({
        user: {
          id: createTestUUID("3001"),
          stationId: createTestUUID("2001"),
          clerkUserId: "test-user-id",
          username: "newstaff",
          role: "staff"
        },
        station: {
          id: createTestUUID("2001"),
          customerId: createTestUUID("1001"),
          name: validInput.stationName,
          address: validInput.stationAddress
        }
      }))

      const result = await setupUserProfile({
        ...validInput,
        username: "newstaff",
        role: "staff"
      })

      expect(result.isSuccess).toBe(true)
      expect(result.data?.user.role).toBe("staff")
      expect(result.data?.station.name).toBe("Test Station")
    })

    it("should create profile without address", async () => {
      // Update transaction mock for no address
      mockDb.transaction.mockImplementationOnce(async callback => ({
        user: {
          id: createTestUUID("3001"),
          stationId: createTestUUID("2001"),
          clerkUserId: "test-user-id",
          username: validInput.username,
          role: validInput.role
        },
        station: {
          id: createTestUUID("2001"),
          customerId: createTestUUID("1001"),
          name: "Station Without Address",
          address: null
        }
      }))

      const { stationAddress, ...inputWithoutAddress } = validInput

      const result = await setupUserProfile({
        ...inputWithoutAddress,
        stationName: "Station Without Address"
      })

      expect(result.isSuccess).toBe(true)
      expect(result.data?.station.name).toBe("Station Without Address")
    })

    it("should reject unauthenticated requests", async () => {
      mockAuth.mockResolvedValue({ userId: null })

      const result = await setupUserProfile(validInput)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Authentication failed")
    })

    it("should reject mismatched user IDs", async () => {
      mockAuth.mockResolvedValue({ userId: "different-user-id" })

      const result = await setupUserProfile({
        ...validInput,
        clerkUserId: "mismatched-user-id"
      })

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Authentication failed")
    })

    it("should prevent duplicate profiles", async () => {
      // Mock existing user found
      mockDb.query.users.findFirst.mockResolvedValueOnce({
        id: createTestUUID("9999"),
        clerkUserId: "test-user-id",
        username: "existing",
        role: "manager"
      })

      const result = await setupUserProfile(validInput)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("User profile already exists")
    })

    it("should prevent duplicate usernames", async () => {
      // Mock no existing user profile for this clerkUserId (first call)
      mockDb.query.users.findFirst.mockResolvedValueOnce(null)

      // But mock existing username for different user (second call)
      mockDb.query.users.findFirst.mockResolvedValueOnce({
        id: createTestUUID("9998"),
        clerkUserId: "other-user",
        username: "testuser",
        role: "manager"
      })

      const result = await setupUserProfile(validInput)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Username already exists")
    })

    it("should validate input data", async () => {
      // Mock Zod to throw validation error for this test
      mockZodParse.mockImplementationOnce(() => {
        const error = new Error("Validation failed")
        error.name = "ZodError"
        ;(error as any).issues = [{ message: "Station name is required" }]
        throw error
      })

      const invalidInput = {
        clerkUserId: "test-user-id",
        stationName: "",
        username: "ab",
        role: "manager"
      }

      const result = await setupUserProfile(invalidInput)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Station name is required")
    })

    it("should handle database transaction failure", async () => {
      mockDb.transaction.mockRejectedValueOnce(new Error("Database error"))

      const result = await setupUserProfile(validInput)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Failed to setup profile")
    })

    it("should validate role enum", async () => {
      // Mock Zod to throw validation error for invalid role
      mockZodParse.mockImplementationOnce(() => {
        const error = new Error("Validation failed")
        error.name = "ZodError"
        ;(error as any).issues = [
          { message: 'Invalid option: expected one of "staff"|"manager"' }
        ]
        throw error
      })

      const invalidRoleInput = {
        ...validInput,
        role: "invalid-role" as any
      }

      const result = await setupUserProfile(invalidRoleInput)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe(
        'Invalid option: expected one of "staff"|"manager"'
      )
    })

    it("should handle Zod validation errors", async () => {
      // Mock Zod to throw validation error
      mockZodParse.mockImplementationOnce(() => {
        const error = new Error("Validation failed")
        error.name = "ZodError"
        ;(error as any).issues = [
          { message: "Username must be at least 3 characters" }
        ]
        throw error
      })

      const result = await setupUserProfile(validInput)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Username must be at least 3 characters")
    })

    it("should create customer record in transaction", async () => {
      await setupUserProfile(validInput)

      expect(mockDb.transaction).toHaveBeenCalledTimes(1)
      expect(typeof mockDb.transaction.mock.calls[0][0]).toBe("function")
    })

    it("should handle successful transaction flow", async () => {
      const result = await setupUserProfile(validInput)

      expect(result.isSuccess).toBe(true)
      expect(result.data).toBeDefined()
      expect(result.data?.user).toBeDefined()
      expect(result.data?.station).toBeDefined()
      expect(result.data?.user.clerkUserId).toBe("test-user-id")
      expect(result.data?.user.username).toBe("testuser")
      expect(result.data?.user.role).toBe("manager")
      expect(result.data?.station.name).toBe("Test Station")
    })

    it("should validate required fields", async () => {
      // Test missing clerkUserId
      mockZodParse.mockImplementationOnce(() => {
        const error = new Error("Validation failed")
        error.name = "ZodError"
        ;(error as any).issues = [{ message: "clerkUserId is required" }]
        throw error
      })

      const { clerkUserId, ...incompleteInput } = validInput

      const result = await setupUserProfile(incompleteInput as any)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("clerkUserId is required")
    })

    it("should handle empty string validation", async () => {
      // Mock Zod to throw validation error for empty strings
      mockZodParse.mockImplementationOnce(() => {
        const error = new Error("Validation failed")
        error.name = "ZodError"
        ;(error as any).issues = [{ message: "Station name is required" }]
        throw error
      })

      const emptyStringInput = {
        clerkUserId: "",
        stationName: "",
        username: "",
        role: "manager"
      }

      const result = await setupUserProfile(emptyStringInput)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Station name is required")
    })

    it("should create records with correct relationships", async () => {
      const result = await setupUserProfile(validInput)

      expect(result.isSuccess).toBe(true)

      if (result.data) {
        expect(result.data.user.clerkUserId).toBe("test-user-id")
        expect(result.data.user.stationId).toBe(createTestUUID("2001"))
        expect(result.data.station.customerId).toBe(createTestUUID("1001"))
      }
    })

    it("should handle generic errors", async () => {
      // Mock a generic error (not ZodError)
      mockDb.transaction.mockRejectedValueOnce(
        new Error("Generic database error")
      )

      const result = await setupUserProfile(validInput)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Failed to setup profile")
    })

    it("should call Zod validation with correct input", async () => {
      await setupUserProfile(validInput)

      expect(mockZodParse).toHaveBeenCalledWith(validInput)
    })

    it("should check for existing user profile before username check", async () => {
      await setupUserProfile(validInput)

      // Should be called twice: once for user profile, once for username
      expect(mockDb.query.users.findFirst).toHaveBeenCalledTimes(2)
    })

    it("should handle optional station address", async () => {
      const inputWithoutAddress = {
        clerkUserId: "test-user-id",
        stationName: "Station No Address",
        username: "testuser",
        role: "manager"
      }

      // Update transaction mock for no address case
      mockDb.transaction.mockImplementationOnce(async callback => ({
        user: {
          id: createTestUUID("3001"),
          stationId: createTestUUID("2001"),
          clerkUserId: "test-user-id",
          username: "testuser",
          role: "manager"
        },
        station: {
          id: createTestUUID("2001"),
          customerId: createTestUUID("1001"),
          name: "Station No Address",
          address: null
        }
      }))

      const result = await setupUserProfile(inputWithoutAddress)

      expect(result.isSuccess).toBe(true)
      expect(result.data?.station.address).toBe(null)
    })
  })

  describe("Edge Cases", () => {
    it("should handle very long usernames", async () => {
      const longUsernameInput = {
        ...validInput,
        username:
          "very_long_username_that_might_cause_issues_but_should_still_work"
      }

      // Update transaction mock
      mockDb.transaction.mockImplementationOnce(async callback => ({
        user: {
          id: createTestUUID("3001"),
          stationId: createTestUUID("2001"),
          clerkUserId: "test-user-id",
          username: longUsernameInput.username,
          role: "manager"
        },
        station: {
          id: createTestUUID("2001"),
          customerId: createTestUUID("1001"),
          name: validInput.stationName,
          address: validInput.stationAddress
        }
      }))

      const result = await setupUserProfile(longUsernameInput)

      expect(result.isSuccess).toBe(true)
      expect(result.data?.user.username).toBe(longUsernameInput.username)
    })

    it("should handle special characters in station name", async () => {
      const specialStationInput = {
        ...validInput,
        stationName: "Shell & Co. Filling Station (Main Branch)"
      }

      // Update transaction mock
      mockDb.transaction.mockImplementationOnce(async callback => ({
        user: {
          id: createTestUUID("3001"),
          stationId: createTestUUID("2001"),
          clerkUserId: "test-user-id",
          username: validInput.username,
          role: "manager"
        },
        station: {
          id: createTestUUID("2001"),
          customerId: createTestUUID("1001"),
          name: specialStationInput.stationName,
          address: validInput.stationAddress
        }
      }))

      const result = await setupUserProfile(specialStationInput)

      expect(result.isSuccess).toBe(true)
      expect(result.data?.station.name).toBe(specialStationInput.stationName)
    })

    it("should handle transaction callback throwing error", async () => {
      mockDb.transaction.mockImplementationOnce(async callback => {
        throw new Error("Transaction callback error")
      })

      const result = await setupUserProfile(validInput)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Failed to setup profile")
    })

    it("should handle multiple ZodErrors", async () => {
      mockZodParse.mockImplementationOnce(() => {
        const error = new Error("Validation failed")
        error.name = "ZodError"
        ;(error as any).issues = [
          { message: "Station name is required" },
          { message: "Username must be at least 3 characters" }
        ]
        throw error
      })

      const result = await setupUserProfile(validInput)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Station name is required") // Should return first error
    })
  })
})
