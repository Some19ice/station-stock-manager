// Mock Clerk authentication
const mockAuth = jest.fn()
jest.mock("@clerk/nextjs/server", () => ({
  auth: mockAuth
}))

// Mock the database with complete chainable structure
const mockDb = {
  query: {
    users: {
      findFirst: jest.fn()
    },
    products: {
      findFirst: jest.fn(),
      findMany: jest.fn()
    },
    suppliers: {
      findFirst: jest.fn()
    }
  },
  insert: jest.fn(() => ({
    values: jest.fn(() => ({
      returning: jest.fn(() =>
        Promise.resolve([{ id: "new-product-id", name: "Test Product" }])
      )
    }))
  })),
  update: jest.fn(() => ({
    set: jest.fn(() => ({
      where: jest.fn(() => ({
        returning: jest.fn(() =>
          Promise.resolve([{ id: "product-123", name: "Updated Product" }])
        )
      }))
    }))
  })),
  delete: jest.fn(() => ({
    where: jest.fn(() => ({
      returning: jest.fn(() => Promise.resolve([{ id: "product-123" }]))
    }))
  }))
}

jest.mock("@/db", () => ({
  db: mockDb
}))

// Mock Drizzle ORM operators and Zod
jest.mock("drizzle-orm", () => ({
  eq: jest.fn(() => "eq-condition"),
  and: jest.fn(() => "and-condition"),
  desc: jest.fn(() => "desc-order"),
  relations: jest.fn((table, callback) => {
    const mockRelations = {
      one: jest.fn(() => ({})),
      many: jest.fn(() => ({}))
    }
    return callback ? callback(mockRelations) : {}
  })
}))

// Mock Zod with ZodError class
class MockZodError extends Error {
  issues = [{ message: "Validation error" }]
  constructor(issues) {
    super("Zod validation error")
    this.name = "ZodError"
    this.issues = issues || [{ message: "Validation error" }]
  }
}

jest.mock("zod", () => ({
  z: {
    object: jest.fn(() => ({
      parse: jest.fn(data => data),
      safeParse: jest.fn(data => ({ success: true, data }))
    })),
    string: jest.fn(() => ({
      min: jest.fn(() => ({
        max: jest.fn(() => ({}))
      })),
      uuid: jest.fn(() => ({}))
    })),
    number: jest.fn(() => ({
      min: jest.fn(() => ({}))
    })),
    enum: jest.fn(() => ({}))
  },
  ZodError: MockZodError
}))

// Import after mocks
const {
  createProduct,
  getProducts,
  updateProduct,
  deleteProduct
} = require("@/actions/products")

describe("Product Actions - Simplified", () => {
  const mockUser = {
    id: "user-123",
    clerkUserId: "clerk-user-123",
    stationId: "station-123",
    username: "testuser",
    role: "manager"
  }

  const mockSupplier = {
    id: "supplier-123",
    name: "Test Supplier",
    stationId: "station-123"
  }

  const mockProduct = {
    id: "product-123",
    name: "Test Product",
    type: "fuel",
    currentStock: 100,
    minStockLevel: 20,
    unitPrice: 1.5,
    stationId: "station-123",
    supplierId: "supplier-123"
  }

  beforeEach(() => {
    jest.clearAllMocks()
    mockAuth.mockResolvedValue({ userId: mockUser.clerkUserId })
    mockDb.query.users.findFirst.mockResolvedValue(mockUser)
    mockDb.query.suppliers.findFirst.mockResolvedValue(mockSupplier)
  })

  describe("createProduct", () => {
    const validProductData = {
      name: "Premium Gasoline",
      type: "fuel",
      currentStock: 1000,
      minStockLevel: 100,
      unitPrice: 200,
      stationId: "station-123",
      supplierId: "supplier-123"
    }

    it("should create product successfully for authenticated manager", async () => {
      mockDb.query.products.findFirst.mockResolvedValue(null) // No existing product

      const result = await createProduct(validProductData)

      expect(result.isSuccess).toBe(true)
      expect(mockAuth).toHaveBeenCalled()
      expect(mockDb.query.users.findFirst).toHaveBeenCalled()
      expect(mockDb.insert).toHaveBeenCalled()
    })

    it("should reject unauthenticated users", async () => {
      mockAuth.mockResolvedValue({ userId: null })

      const result = await createProduct(validProductData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })

    it("should prevent duplicate product names", async () => {
      mockDb.query.products.findFirst.mockResolvedValue(mockProduct)

      const result = await createProduct(validProductData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Product name already exists for this station")
    })

    it("should validate supplier exists", async () => {
      mockDb.query.suppliers.findFirst.mockResolvedValue(null)

      const result = await createProduct(validProductData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Supplier not found")
    })
  })

  describe("getProducts", () => {
    it("should return products for authenticated user", async () => {
      mockDb.query.products.findMany.mockResolvedValue([mockProduct])

      const result = await getProducts("station-123")

      expect(result.isSuccess).toBe(true)
      expect(result.data).toEqual([mockProduct])
      expect(mockAuth).toHaveBeenCalled()
    })

    it("should reject unauthenticated users", async () => {
      mockAuth.mockResolvedValue({ userId: null })

      const result = await getProducts("station-123")

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })
  })

  describe("updateProduct", () => {
    const updateData = {
      id: "product-123",
      name: "Updated Product",
      unitPrice: 2.0
    }

    it("should update product successfully", async () => {
      mockDb.query.products.findFirst.mockResolvedValue(mockProduct)

      const result = await updateProduct(updateData)

      expect(result.isSuccess).toBe(true)
      expect(mockDb.update).toHaveBeenCalled()
    })

    it("should reject unauthenticated users", async () => {
      mockAuth.mockResolvedValue({ userId: null })

      const result = await updateProduct(updateData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })

    it("should handle non-existent products", async () => {
      mockDb.query.products.findFirst.mockResolvedValue(null)

      const result = await updateProduct(updateData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Product not found")
    })
  })

  describe("deleteProduct", () => {
    it("should delete product successfully", async () => {
      mockDb.query.products.findFirst.mockResolvedValue(mockProduct)

      const result = await deleteProduct("product-123")

      expect(result.isSuccess).toBe(true)
      expect(mockDb.delete).toHaveBeenCalled()
    })

    it("should reject unauthenticated users", async () => {
      mockAuth.mockResolvedValue({ userId: null })

      const result = await deleteProduct("product-123")

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })

    it("should handle non-existent products", async () => {
      mockDb.query.products.findFirst.mockResolvedValue(null)

      const result = await deleteProduct("product-123")

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Product not found")
    })
  })

  describe("Error Handling", () => {
    it("should handle database errors gracefully", async () => {
      mockDb.query.products.findMany.mockRejectedValue(new Error("DB Error"))

      const result = await getProducts("station-123")

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Failed to fetch products")
    })
  })
})
