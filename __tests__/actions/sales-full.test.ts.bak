// Mock setup comes first

// Mock Clerk authentication
const mockAuth = jest.fn()
jest.mock("@clerk/nextjs/server", () => ({
  auth: mockAuth
}))

// Mock the database
const mockDb = {
  transaction: jest.fn(),
  query: {
    users: {
      findFirst: jest.fn()
    },
    products: {
      findFirst: jest.fn(),
      findMany: jest.fn()
    },
    transactions: {
      findMany: jest.fn()
    }
  },
  insert: jest.fn(),
  update: jest.fn(),
  select: jest.fn()
}

jest.mock("@/db", () => ({
  db: mockDb
}))

// Mock Drizzle ORM operators
jest.mock("drizzle-orm", () => ({
  eq: jest.fn(() => "eq-condition"),
  and: jest.fn(() => "and-condition"),
  desc: jest.fn(() => "desc-order"),
  sql: jest.fn(() => ({ raw: "sql-query" })),
  gte: jest.fn(() => "gte-condition"),
  lte: jest.fn(() => "lte-condition")
}))

// Import after mocks
const {
  recordSale,
  getSalesHistory,
  getTodaysSalesSummary
} = require("@/actions/sales")

describe("Sales Actions", () => {
  const mockUser = {
    id: "user-123",
    clerkUserId: "clerk-user-123",
    stationId: "station-123",
    username: "testuser",
    role: "staff"
  }

  const mockProduct = {
    id: "product-1",
    name: "Premium Gasoline",
    type: "pms",
    unit: "liters",
    currentStock: 100,
    unitPrice: 150
  }

  const mockSaleData = {
    stationId: "station-123",
    items: [
      {
        productId: "product-1",
        quantity: 10,
        unitPrice: 150
      }
    ],
    totalAmount: 1500
  }

  beforeEach(() => {
    jest.clearAllMocks()

    // Set up default successful auth
    mockAuth.mockResolvedValue({ userId: "clerk-user-123" })

    // Set up default user lookup
    mockDb.query.users.findFirst.mockResolvedValue(mockUser)

    // Set up default product lookup
    mockDb.query.products.findFirst.mockResolvedValue(mockProduct)
  })

  describe("recordSale", () => {
    it("should record a sale successfully", async () => {
      // Mock successful transaction
      mockDb.transaction.mockImplementation(async callback => {
        const tx = {
          insert: jest.fn().mockReturnValue({
            values: jest.fn().mockReturnValue({
              returning: jest.fn().mockResolvedValue([
                {
                  id: "transaction-123",
                  totalAmount: "1500"
                }
              ])
            })
          }),
          update: jest.fn().mockReturnValue({
            set: jest.fn().mockReturnValue({
              where: jest.fn().mockResolvedValue([mockProduct])
            })
          })
        }
        return callback(tx)
      })

      const result = await recordSale(mockSaleData)

      expect(result.isSuccess).toBe(true)
      expect(mockDb.transaction).toHaveBeenCalled()
    })

    it("should fail when user does not belong to station", async () => {
      // Mock user from different station
      mockDb.query.users.findFirst.mockResolvedValue({
        ...mockUser,
        stationId: "different-station-123"
      })

      const result = await recordSale(mockSaleData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Access denied for this station")
    })

    it("should fail with insufficient stock", async () => {
      // Mock product with insufficient stock
      mockDb.query.products.findFirst.mockResolvedValue({
        ...mockProduct,
        currentStock: 5 // Less than requested quantity of 10
      })

      const result = await recordSale(mockSaleData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toContain("Insufficient stock")
    })

    it("should validate input data", async () => {
      const invalidSaleData = {
        stationId: "",
        items: [],
        totalAmount: -100
      }

      const result = await recordSale(invalidSaleData as any)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBeDefined()
    })

    it("should handle authentication failure", async () => {
      mockAuth.mockResolvedValue({ userId: null })

      const result = await recordSale(mockSaleData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })

    it("should handle transaction failure", async () => {
      mockDb.transaction.mockRejectedValue(new Error("Database error"))

      const result = await recordSale(mockSaleData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Failed to record sale")
    })
  })

  describe("getSalesHistory", () => {
    const mockHistoryData = {
      stationId: "station-123",
      startDate: new Date("2024-01-01"),
      endDate: new Date("2024-01-31")
    }

    const mockTransactions = [
      {
        id: "transaction-1",
        stationId: "station-123",
        userId: "user-123",
        totalAmount: "1500",
        transactionDate: new Date("2024-01-15"),
        syncStatus: "synced",
        createdAt: new Date("2024-01-15"),
        items: [
          {
            id: "item-1",
            quantity: "10",
            totalPrice: "1500",
            product: {
              id: "product-1",
              name: "Premium Gasoline",
              type: "pms",
              unit: "liters"
            }
          }
        ]
      }
    ]

    it("should fetch sales history successfully", async () => {
      mockDb.query.transactions.findMany.mockResolvedValue(mockTransactions)

      const result = await getSalesHistory(mockHistoryData)

      expect(result.isSuccess).toBe(true)
      expect(result.data).toBeDefined()
      expect(Array.isArray(result.data)).toBe(true)
    })

    it("should handle authentication failure", async () => {
      mockAuth.mockResolvedValue({ userId: null })

      const result = await getSalesHistory(mockHistoryData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })

    it("should handle database error", async () => {
      mockDb.query.transactions.findMany.mockRejectedValue(
        new Error("Database error")
      )

      const result = await getSalesHistory(mockHistoryData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Failed to fetch sales history")
    })
  })

  describe("getTodaysSalesSummary", () => {
    it("should fetch today's sales summary successfully", async () => {
      const mockSummaryQuery = {
        then: jest.fn().mockResolvedValue([
          {
            totalTransactions: 1,
            totalAmount: "1500"
          }
        ])
      }

      mockDb.select = jest.fn().mockReturnValue({
        from: jest.fn().mockReturnValue({
          where: jest.fn().mockReturnValue(mockSummaryQuery)
        })
      })

      const result = await getTodaysSalesSummary("station-123")

      expect(result.isSuccess).toBe(true)
      expect(result.data).toBeDefined()
      expect(result.data?.totalTransactions).toBe(1)
      expect(result.data?.totalAmount).toBe(1500)
    })

    it("should handle empty sales data", async () => {
      const mockSummaryQuery = {
        then: jest.fn().mockResolvedValue([])
      }

      mockDb.select = jest.fn().mockReturnValue({
        from: jest.fn().mockReturnValue({
          where: jest.fn().mockReturnValue(mockSummaryQuery)
        })
      })

      const result = await getTodaysSalesSummary("station-123")

      expect(result.isSuccess).toBe(true)
      expect(result.data?.totalTransactions).toBe(0)
      expect(result.data?.totalAmount).toBe(0)
    })

    it("should handle authentication failure", async () => {
      mockAuth.mockResolvedValue({ userId: null })

      const result = await getTodaysSalesSummary("station-123")

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })

    it("should handle user not belonging to station", async () => {
      mockDb.query.users.findFirst.mockResolvedValue({
        ...mockUser,
        stationId: "different-station"
      })

      const result = await getTodaysSalesSummary("station-123")

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Access denied for this station")
    })

    it("should handle database error", async () => {
      mockDb.select = jest.fn().mockImplementation(() => {
        throw new Error("Database error")
      })

      const result = await getTodaysSalesSummary("station-123")

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Failed to fetch sales summary")
    })
  })
})
