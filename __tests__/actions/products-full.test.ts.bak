// Mock Clerk authentication
const mockAuth = jest.fn()
jest.mock("@clerk/nextjs/server", () => ({
  auth: mockAuth
}))

// Mock the database
const mockDb = {
  transaction: jest.fn(),
  query: {
    users: {
      findFirst: jest.fn()
    },
    products: {
      findFirst: jest.fn(),
      findMany: jest.fn()
    },
    suppliers: {
      findFirst: jest.fn()
    }
  },
  insert: jest.fn(),
  update: jest.fn(),
  delete: jest.fn()
}

jest.mock("@/db", () => ({
  db: mockDb
}))

// Mock Drizzle ORM operators
jest.mock("drizzle-orm", () => ({
  eq: jest.fn(() => "eq-condition"),
  and: jest.fn(() => "and-condition"),
  desc: jest.fn(() => "desc-order"),
  asc: jest.fn(() => "asc-order")
}))

// Import after mocks
const {
  createProduct,
  getProducts,
  updateProduct,
  deleteProduct
} = require("@/actions/products")

describe("Product Actions", () => {
  const mockManagerUser = {
    id: "user-123",
    clerkUserId: "clerk-user-123",
    stationId: "station-123",
    username: "manager",
    role: "manager"
  }

  const mockStaffUser = {
    id: "user-124",
    clerkUserId: "clerk-user-124",
    stationId: "station-123",
    username: "staff",
    role: "staff"
  }

  const mockProduct = {
    id: "product-123",
    name: "Premium Gasoline",
    type: "fuel",
    currentStock: 1000,
    minStockLevel: 100,
    unitPrice: 200,
    stationId: "station-123",
    supplierId: "supplier-123",
    isActive: true,
    createdAt: new Date("2024-01-01"),
    updatedAt: new Date("2024-01-01")
  }

  const mockSupplier = {
    id: "supplier-123",
    name: "Test Supplier",
    stationId: "station-123",
    isActive: true
  }

  beforeEach(() => {
    jest.clearAllMocks()

    // Set up default successful auth
    mockAuth.mockResolvedValue({ userId: "clerk-user-123" })

    // Set up default manager user lookup
    mockDb.query.users.findFirst.mockResolvedValue(mockManagerUser)

    // Set up default supplier lookup
    mockDb.query.suppliers.findFirst.mockResolvedValue(mockSupplier)
  })

  describe("createProduct", () => {
    const validProductData = {
      name: "Premium Gasoline",
      type: "fuel",
      currentStock: 1000,
      minStockLevel: 100,
      unitPrice: 200,
      stationId: "station-123",
      supplierId: "supplier-123"
    }

    it("should create product successfully for authenticated user", async () => {
      mockDb.insert = jest.fn().mockReturnValue({
        values: jest.fn().mockReturnValue({
          returning: jest.fn().mockResolvedValue([mockProduct])
        })
      })

      const result = await createProduct(validProductData)

      expect(result.isSuccess).toBe(true)
      expect(result.data).toBeDefined()
    })

    it("should reject creation for unauthenticated users", async () => {
      mockAuth.mockResolvedValue({ userId: null })

      const result = await createProduct(validProductData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })

    it("should handle valid product data structure", async () => {
      mockDb.insert = jest.fn().mockReturnValue({
        values: jest.fn().mockReturnValue({
          returning: jest.fn().mockResolvedValue([mockProduct])
        })
      })

      const result = await createProduct(validProductData)

      expect(result.isSuccess).toBe(true)
      expect(result.data?.name).toBe("Premium Gasoline")
      expect(result.data?.type).toBe("fuel")
      expect(result.data?.currentStock).toBe(1000)
    })

    it("should validate required fields", async () => {
      const invalidData = {
        name: "",
        type: "fuel",
        currentStock: -10,
        minStockLevel: -5,
        unitPrice: -100,
        stationId: "",
        supplierId: ""
      }

      const result = await createProduct(invalidData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBeDefined()
    })

    it("should reject access for different station users", async () => {
      mockDb.query.users.findFirst.mockResolvedValue({
        ...mockManagerUser,
        stationId: "different-station"
      })

      const result = await createProduct(validProductData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Access denied for this station")
    })

    it("should handle database errors", async () => {
      mockDb.insert = jest.fn().mockImplementation(() => {
        throw new Error("Database error")
      })

      const result = await createProduct(validProductData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Failed to create product")
    })

    it("should validate supplier exists and belongs to station", async () => {
      mockDb.query.suppliers.findFirst.mockResolvedValue(null)

      const result = await createProduct(validProductData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Supplier not found or not accessible")
    })
  })

  describe("getProducts", () => {
    const validStationId = "station-123"
    const mockProducts = [
      {
        ...mockProduct,
        id: "product-1",
        name: "Premium Gasoline"
      },
      {
        ...mockProduct,
        id: "product-2",
        name: "Engine Oil"
      }
    ]

    it("should handle unauthenticated users", async () => {
      mockAuth.mockResolvedValue({ userId: null })

      const result = await getProducts(validStationId)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })

    it("should return products for authenticated users", async () => {
      mockDb.query.products.findMany.mockResolvedValue(mockProducts)

      const result = await getProducts(validStationId)

      expect(result.isSuccess).toBe(true)
      expect(result.data).toEqual(mockProducts)
    })

    it("should handle access denial for different station", async () => {
      mockDb.query.users.findFirst.mockResolvedValue({
        ...mockManagerUser,
        stationId: "different-station"
      })

      const result = await getProducts(validStationId)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Access denied for this station")
    })

    it("should return empty array when no products exist", async () => {
      mockDb.query.products.findMany.mockResolvedValue([])

      const result = await getProducts(validStationId)

      expect(result.isSuccess).toBe(true)
      expect(result.data).toEqual([])
    })

    it("should handle database errors", async () => {
      mockDb.query.products.findMany.mockRejectedValue(
        new Error("Database error")
      )

      const result = await getProducts(validStationId)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Failed to fetch products")
    })
  })

  describe("updateProduct", () => {
    const updateData = {
      id: "product-123",
      name: "Updated Premium Gasoline",
      currentStock: 1500,
      minStockLevel: 150,
      unitPrice: 220
    }

    it("should handle product updates", async () => {
      mockDb.query.products.findFirst.mockResolvedValue(mockProduct)
      mockDb.update = jest.fn().mockReturnValue({
        set: jest.fn().mockReturnValue({
          where: jest.fn().mockReturnValue({
            returning: jest
              .fn()
              .mockResolvedValue([{ ...mockProduct, ...updateData }])
          })
        })
      })

      const result = await updateProduct(updateData)

      expect(result.isSuccess).toBe(true)
    })

    it("should validate product ID format", async () => {
      const invalidData = {
        id: "invalid-id",
        name: "Test Product"
      }

      const result = await updateProduct(invalidData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBeDefined()
    })

    it("should reject unauthenticated users", async () => {
      mockAuth.mockResolvedValue({ userId: null })

      const result = await updateProduct(updateData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })

    it("should reject access for different station users", async () => {
      mockDb.query.users.findFirst.mockResolvedValue({
        ...mockManagerUser,
        stationId: "different-station"
      })

      const result = await updateProduct(updateData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Access denied for this station")
    })

    it("should handle non-existent products", async () => {
      mockDb.query.products.findFirst.mockResolvedValue(null)

      const result = await updateProduct(updateData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Product not found")
    })

    it("should handle database errors", async () => {
      mockDb.query.products.findFirst.mockResolvedValue(mockProduct)
      mockDb.update = jest.fn().mockImplementation(() => {
        throw new Error("Database error")
      })

      const result = await updateProduct(updateData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Failed to update product")
    })

    it("should validate stock levels", async () => {
      const invalidStockData = {
        id: "product-123",
        currentStock: -10,
        minStockLevel: -5
      }

      const result = await updateProduct(invalidStockData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBeDefined()
    })
  })

  describe("deleteProduct", () => {
    it("should handle product deletion for managers", async () => {
      mockDb.query.products.findFirst.mockResolvedValue(mockProduct)
      mockDb.update = jest.fn().mockReturnValue({
        set: jest.fn().mockReturnValue({
          where: jest.fn().mockReturnValue({
            returning: jest
              .fn()
              .mockResolvedValue([{ ...mockProduct, isActive: false }])
          })
        })
      })

      const result = await deleteProduct("product-123")

      expect(result.isSuccess).toBe(true)
      expect(result.data?.isActive).toBe(false)
    })

    it("should reject deletion by staff users", async () => {
      mockDb.query.users.findFirst.mockResolvedValue(mockStaffUser)

      const result = await deleteProduct("product-123")

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Only managers can delete products")
    })

    it("should reject unauthenticated users", async () => {
      mockAuth.mockResolvedValue({ userId: null })

      const result = await deleteProduct("product-123")

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })

    it("should handle non-existent products", async () => {
      mockDb.query.products.findFirst.mockResolvedValue(null)

      const result = await deleteProduct("product-123")

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Product not found")
    })

    it("should handle database errors", async () => {
      mockDb.query.products.findFirst.mockResolvedValue(mockProduct)
      mockDb.update = jest.fn().mockImplementation(() => {
        throw new Error("Database error")
      })

      const result = await deleteProduct("product-123")

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBe("Failed to delete product")
    })
  })

  describe("Input Validation", () => {
    it("should validate product type enum", async () => {
      const invalidTypeData = {
        name: "Test Product",
        type: "invalid-type" as any,
        currentStock: 100,
        minStockLevel: 10,
        unitPrice: 50,
        stationId: "station-123",
        supplierId: "supplier-123"
      }

      const result = await createProduct(invalidTypeData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBeDefined()
    })

    it("should validate numeric fields", async () => {
      const invalidNumericData = {
        name: "Test Product",
        type: "fuel",
        currentStock: "not-a-number" as any,
        minStockLevel: "also-not-a-number" as any,
        unitPrice: "definitely-not-a-number" as any,
        stationId: "station-123",
        supplierId: "supplier-123"
      }

      const result = await createProduct(invalidNumericData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBeDefined()
    })

    it("should validate minimum values", async () => {
      const negativeValuesData = {
        name: "Test Product",
        type: "fuel",
        currentStock: -100,
        minStockLevel: -10,
        unitPrice: -50,
        stationId: "station-123",
        supplierId: "supplier-123"
      }

      const result = await createProduct(negativeValuesData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBeDefined()
    })

    it("should validate required string fields", async () => {
      const emptyStringData = {
        name: "",
        type: "fuel",
        currentStock: 100,
        minStockLevel: 10,
        unitPrice: 50,
        stationId: "",
        supplierId: ""
      }

      const result = await createProduct(emptyStringData)

      expect(result.isSuccess).toBe(false)
      expect(result.error).toBeDefined()
    })
  })
})
